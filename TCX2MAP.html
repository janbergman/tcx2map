<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Orienteering Map - Full View</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent scrollbars from appearing due to slight overflows */
            font-family: sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            flex-direction: row;
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            position: relative; /* For positioning the controls panel */
        }
        .controls-panel {
            width: 320px; /* Desired width of the panel */
            min-width: 320px; /* Ensure it doesn't shrink too much */
            padding: 15px;
            background-color: #fff;
            border-radius: 0 8px 8px 0; /* Rounded corners on the right */
            box-shadow: 2px 0 10px rgba(0,0,0,0.2);
            
            position: absolute; /* For sliding */
            left: 0;
            top: 0;
            height: 100vh; /* Full height */
            z-index: 10; /* Above canvas */
            
            transform: translateX(-290px); /* Hide most of it, leave 30px visible */
            transition: transform 0.3s ease-in-out;
            
            overflow-y: auto; /* Scroll if content overflows */
            box-sizing: border-box;
        }
        .controls-panel:hover,
        .controls-panel.open { /* Class to force open via JS if needed */
            transform: translateX(0px); /* Slide in */
        }

        .controls-panel h3, .controls-panel h4 {
            margin-top: 10px;
            margin-bottom: 5px;
            color: #333;
        }
        .controls-panel button {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls-panel button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .controls-panel button:hover:not(:disabled) {
            background-color: #45a049;
        }
        .controls-panel input[type="file"] {
            width: calc(100% - 0px); /* Adjusted for box-sizing */
            margin-bottom: 10px;
            padding: 5px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .controls-panel label {
            display: block;
            margin-top: 8px;
            margin-bottom: 3px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .controls-panel input[type="color"],
        .controls-panel input[type="number"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 8px;
        }


        .canvas-container {
            flex-grow: 1; /* Take remaining space */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e0e0e0;
            /* Removed border-radius and specific overflow: hidden as it's now the main stage */
            height: 100%; /* Fill height of container */
            width: 100%;  /* Fill width of container */
            cursor: default;
            margin-left: 30px; /* Space for the visible part of the collapsed panel */
            box-sizing: border-box;
        }
        canvas {
            display: block;
            background-color: #fff; /* Or transparent if map always covers */
            /* box-shadow: 0 0 10px rgba(0,0,0,0.1); Removed, less relevant for full screen */
            max-width: 100%; /* Ensure canvas doesn't overflow its container */
            max-height: 100%;
        }
        #status {
            color: blue;
            min-height: 2.4em;
            font-weight: bold;
            margin-top: 10px;
            border: 1px dashed #ccc;
            padding: 5px;
            font-size: 0.9em;
            background-color: #f9f9f9;
        }
        #globalAnchorList {
            font-size:0.8em; 
            padding-left:15px;
            list-style-type: none;
        }
        #globalAnchorList li {
            padding: 2px 0;
        }

    </style>
</head>
<body>
    <!-- Removed H1 -->
    <div class="container">
        <div class="controls-panel"> <h3>1. Load Files</h3>
            <label for="mapFile">Map Image:</label>
            <input type="file" id="mapFile" accept="image/*">

            <label for="tcxFile">TCX Track File:</label>
            <input type="file" id="tcxFile" accept=".tcx,application/vnd.garmin.tcx+xml">

            <div id="status">Load map and TCX file.</div>

            <h3>2. Alignment</h3>
            <button id="startGlobalAlignBtn" disabled>Start 2-Point Global Alignment</button>
            <button id="resetAlignmentBtn" disabled>Reset Alignment & Controls</button>
            <button id="zoomToFitMapBtn" disabled>Zoom to Fit Map</button>

            <h4>Selected for Global:</h4>
            <ul id="globalAnchorList"></ul>

            <h3>3. Appearance</h3>
             <label for="trackColor">Track Color:</label>
             <input type="color" id="trackColor" value="#FF0000" style="width:100px;">
             <label for="trackWidth">Track Width (px on screen):</label>
             <input type="number" id="trackWidth" value="2" min="0.5" max="10" step="0.5" style="width:60px;">
             <label for="controlColor">Ctrl Color (Placed):</label>
             <input type="color" id="controlColor" value="#FF0000" style="width:100px;">
             <label for="controlColorGlobal">Ctrl Color (Global):</label>
             <input type="color" id="controlColorGlobal" value="#00AAFF" style="width:100px;">
             <label for="controlColorInitial">Ctrl Color (Initial):</label>
             <input type="color" id="controlColorInitial" value="#AAAAAA" style="width:100px;">
             <label for="controlRadius">Ctrl Radius (px on screen):</label>
             <input type="number" id="controlRadius" value="16" min="1" max="40" step="1" style="width:60px;">
             <label for="controlColorCustom">Ctrl Color (Custom):</label>
             <input type="color" id="controlColorCustom" value="#0000FF" style="width:100px;">

            <h3>4. Export</h3>
            <button id="saveImageBtn" disabled>Save Map with Track</button>
        </div>

        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const mapFileInput = document.getElementById('mapFile');
        const tcxFileInput = document.getElementById('tcxFile');
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const startGlobalAlignBtn = document.getElementById('startGlobalAlignBtn');
        const resetAlignmentBtn = document.getElementById('resetAlignmentBtn');
        const globalAnchorListEl = document.getElementById('globalAnchorList');
        const zoomToFitMapBtn = document.getElementById('zoomToFitMapBtn');
        const controlsPanelEl = document.querySelector('.controls-panel');

        const trackColorInput = document.getElementById('trackColor'), trackWidthInput = document.getElementById('trackWidth'),
              controlColorInput = document.getElementById('controlColor'), controlRadiusInput = document.getElementById('controlRadius'),
              controlColorGlobalInput = document.getElementById('controlColorGlobal'), controlColorInitialInput = document.getElementById('controlColorInitial'),
              controlColorCustomInput = document.getElementById('controlColorCustom');

        // NEW DOM ELEMENT FOR SAVE BUTTON
        const saveImageBtn = document.getElementById('saveImageBtn');


        // --- State Variables (mostly same) ---
        let mapImage = null;
        let originalMapFileName = 'map_with_track.png'; // Default filename if original is not available
        let originalTrackPoints = [];
        let modelTrackPoints = [];
        let controls = [];
        let displayTrackScreenPoints = [];

        let geoTrackStats = {};
        let initialDisplayTransform = { scale: 1, rotation: 0, tx: 0, ty: 0 };
        let activeGlobalTransform = null;

        let viewTransform = { scale: 1.0, offsetX: 0, offsetY: 0 };
        const MIN_ZOOM = 0.05; const MAX_ZOOM = 20.0;

        let currentMode = 'idle';
        let globalAnchorPairs = [];
        let selectedControlForPlacementId = null;

        let activeDragControlId = null;
        let isPanning = false;
        let lastPanX = 0, lastPanY = 0;
        let didDrag = false; // To distinguish a click from a drag-release

        let appearance = { trackColor: '#FF0000', trackWidth: 2, controlColor: '#FF0000', controlColorGlobal: '#00AAFF', controlColorInitial: '#AAAAAA', controlRadius: 16, controlColorCustom: '#0000FF' };
        let customControlIdCounter = 0;

        // --- Initialization ---
        function init() {
            mapFileInput.addEventListener('change', loadMapImage);
            tcxFileInput.addEventListener('change', loadTcxFile);
            startGlobalAlignBtn.addEventListener('click', startGlobalAlignment);
            resetAlignmentBtn.addEventListener('click', resetAlignment);
            zoomToFitMapBtn.addEventListener('click', zoomToFitMap);
            // NEW EVENT LISTENER FOR SAVE BUTTON
            saveImageBtn.addEventListener('click', saveImage);


            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleMouseWheel, { passive: false });

            [trackColorInput, trackWidthInput, controlColorInput, controlRadiusInput, controlColorGlobalInput, controlColorInitialInput, controlColorCustomInput].forEach(inp => {
                inp.addEventListener('input', updateAppearanceFromUI);
            });

            updateAppearanceFromUI();
            updateButtonStates();
            const canvasContainer = document.querySelector('.canvas-container');
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            redrawCanvas();
        }

        function updateAppearanceFromUI(){
            appearance.trackColor = trackColorInput.value;
            appearance.trackWidth = parseFloat(trackWidthInput.value);
            appearance.controlColor = controlColorInput.value;
            appearance.controlColorGlobal = controlColorGlobalInput.value;
            appearance.controlColorInitial = controlColorInitialInput.value;
            appearance.controlRadius = parseFloat(controlRadiusInput.value);
            appearance.controlColorCustom = controlColorCustomInput.value;
            if (canvas.width > 0 && canvas.height > 0) redrawCanvas();
        }

        function updateStatus(message) { statusEl.innerHTML = message; }

        function updateButtonStates() {
            const filesLoaded = mapImage && originalTrackPoints.length > 0;
            startGlobalAlignBtn.disabled = !filesLoaded || (currentMode !== 'idle' && currentMode !== 'fineTuning');
            resetAlignmentBtn.disabled = !filesLoaded;
            zoomToFitMapBtn.disabled = !mapImage;
            // UPDATE SAVE BUTTON STATE
            saveImageBtn.disabled = !mapImage || displayTrackScreenPoints.length === 0;
        }

        function mapToScreen(mapX, mapY) {
            return {
                x: (mapX - viewTransform.offsetX) * viewTransform.scale,
                y: (mapY - viewTransform.offsetY) * viewTransform.scale
            };
        }

        function screenToMap(screenX, screenY) {
            return {
                x: (screenX / viewTransform.scale) + viewTransform.offsetX,
                y: (screenY / viewTransform.scale) + viewTransform.offsetY
            };
        }

        function transformModelToMapPixels(modelX, modelY, trackGeoTransform) {
            const s = trackGeoTransform.scale;
            const R = trackGeoTransform.rotation;
            const cosR = Math.cos(R);
            const sinR = Math.sin(R);
            const mapX = s * (modelX * cosR - modelY * sinR) + trackGeoTransform.tx;
            const mapY = s * (-modelX * sinR - modelY * cosR) + trackGeoTransform.ty;
            return { x: mapX, y: mapY };
        }

        function loadMapImage(event) {
            const file = event.target.files[0]; if (!file) return;

            // Reset all track and alignment data for a clean slate
            originalTrackPoints = [];
            modelTrackPoints = [];
            controls = [];
            displayTrackScreenPoints = [];
            activeGlobalTransform = null;
            globalAnchorPairs = [];
            currentMode = 'idle';
            updateGlobalAnchorListUI();
            
            originalMapFileName = file.name; // Store original filename
            const reader = new FileReader();
            reader.onload = (e) => {
                mapImage = new Image();
                mapImage.onload = () => {
                    const canvasContainer = document.querySelector('.canvas-container');
                    canvas.width = canvasContainer.clientWidth;
                    canvas.height = canvasContainer.clientHeight;
                    zoomToFitMap();
                    updateStatus('Map loaded. Load TCX file.');
                    updateButtonStates();
                    redrawCanvas(); // Explicitly redraw to show just the map
                };
                mapImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function zoomToFitMap() {
            if (!mapImage || !canvas.width || !canvas.height ) return;
            const mw = mapImage.width; const mh = mapImage.height;
            const cw = canvas.width; const ch = canvas.height;
            if (mw === 0 || mh === 0) return;
            const scaleX = cw / mw; const scaleY = ch / mh;
            viewTransform.scale = Math.min(scaleX, scaleY);
            viewTransform.scale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewTransform.scale));
            viewTransform.offsetX = (mw - cw / viewTransform.scale) / 2;
            viewTransform.offsetY = (mh - ch / viewTransform.scale) / 2;
            redrawCanvas();
        }

        function loadTcxFile(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    // Clear all old track and alignment data first
                    originalTrackPoints = []; 
                    controls = []; 
                    activeGlobalTransform = null; 
                    globalAnchorPairs = [];
                    updateGlobalAnchorListUI();

                    const xmlDoc = new DOMParser().parseFromString(e.target.result, "application/xml");
                    if (xmlDoc.getElementsByTagName("parsererror").length > 0) throw new Error("Invalid XML");
                    let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity, pointIndex = 0;
                    Array.from(xmlDoc.getElementsByTagName('Trackpoint')).forEach(tpNode => {
                        const posNode = tpNode.getElementsByTagName('Position')[0];
                        if (posNode) {
                            const lat = parseFloat(posNode.getElementsByTagName('LatitudeDegrees')[0]?.textContent);
                            const lon = parseFloat(posNode.getElementsByTagName('LongitudeDegrees')[0]?.textContent);
                            if (!isNaN(lat) && !isNaN(lon)) {
                                originalTrackPoints.push({ lat, lon, originalIndex: pointIndex++ });
                                minLat = Math.min(minLat, lat); maxLat = Math.max(maxLat, lat);
                                minLon = Math.min(minLon, lon); maxLon = Math.max(maxLon, lon);
                            }
                        }
                    });
                    if (originalTrackPoints.length === 0) throw new Error("No trackpoints found.");
                    geoTrackStats = { minLat, maxLat, minLon, maxLon,
                        centerLat: minLat + (maxLat - minLat) / 2, centerLon: minLon + (maxLon - minLon) / 2,
                        heightDeg: maxLat - minLat, lonCorrectionFactor: Math.cos(((minLat + maxLat) / 2) * Math.PI / 180)
                    };
                    geoTrackStats.widthDegCorrected = (maxLon - minLon) * geoTrackStats.lonCorrectionFactor;
                    let controlIdCounter = 0;
                    Array.from(xmlDoc.getElementsByTagName('Lap')).forEach(lapNode => {
                         const firstLapTpNode = lapNode.getElementsByTagName('Trackpoint')[0];
                         if(firstLapTpNode) {
                            const posNode = firstLapTpNode.getElementsByTagName('Position')[0];
                             if (posNode) {
                                const lat = parseFloat(posNode.getElementsByTagName('LatitudeDegrees')[0]?.textContent);
                                const lon = parseFloat(posNode.getElementsByTagName('LongitudeDegrees')[0]?.textContent);
                                const controlOTrackPoint = originalTrackPoints.find(otp => Math.abs(otp.lat - lat) < 1e-7 && Math.abs(otp.lon - lon) < 1e-7);
                                if (controlOTrackPoint && !isNaN(lat) && !isNaN(lon)) {
                                   controls.push({
                                        id: `control-lap-${controlIdCounter++}`, originalLat: lat, originalLon: lon,
                                        modelX: 0, modelY: 0, mapX: 0, mapY: 0,
                                        isUserManuallyPositioned: false, isGlobalAnchor: false,
                                        originalTrackPointIndex: controlOTrackPoint.originalIndex
                                    });
                                }
                            }
                         }
                    });
                    if (originalTrackPoints.length > 0) {
                        const trackStartIndex = 0;
                        if (!controls.find(c => c.originalTrackPointIndex === trackStartIndex)) {
                            controls.push({ id: 'control-track-start',
                                originalLat: originalTrackPoints[trackStartIndex].lat, originalLon: originalTrackPoints[trackStartIndex].lon,
                                modelX: 0, modelY: 0, mapX: 0, mapY: 0,
                                isUserManuallyPositioned: false, isGlobalAnchor: false,
                                originalTrackPointIndex: trackStartIndex });
                        }
                    }
                    if (originalTrackPoints.length > 0) {
                        const trackEndIndex = originalTrackPoints[originalTrackPoints.length - 1].originalIndex;
                        if (!controls.find(c => c.originalTrackPointIndex === trackEndIndex)) {
                             controls.push({ id: 'control-track-end',
                                originalLat: originalTrackPoints[originalTrackPoints.length - 1].lat,
                                originalLon: originalTrackPoints[originalTrackPoints.length - 1].lon,
                                modelX: 0, modelY: 0, mapX: 0, mapY: 0,
                                isUserManuallyPositioned: false, isGlobalAnchor: false,
                                originalTrackPointIndex: trackEndIndex });
                        }
                    }
                    controls.sort((a,b) => a.originalTrackPointIndex - b.originalTrackPointIndex);
                    if (mapImage) processLoadedDataAndSetInitialDisplay(); else updateStatus(`TCX loaded. Load map.`);
                    updateButtonStates();
                } catch (err) { updateStatus(`Error parsing TCX: ${err.message}`); console.error(err); }
            };
            reader.readAsText(file);
        }

        function processLoadedDataAndSetInitialDisplay() {
            modelTrackPoints = originalTrackPoints.map(p => ({
                correctedX: (p.lon - geoTrackStats.centerLon) * geoTrackStats.lonCorrectionFactor,
                correctedY: p.lat - geoTrackStats.centerLat,
                originalIndex: p.originalIndex
            }));
            controls.forEach(c => {
                c.modelX = (c.originalLon - geoTrackStats.centerLon) * geoTrackStats.lonCorrectionFactor;
                c.modelY = (c.originalLat - geoTrackStats.centerLat);
            });
            if (!mapImage) { updateStatus("Map image not loaded, cannot process further."); return; }
            const trackModelWidth = geoTrackStats.widthDegCorrected || 0.0001;
            const trackModelHeight = geoTrackStats.heightDeg || 0.0001;
            let scaleFactorMap = Math.min( (mapImage.width * 0.8) / trackModelWidth, (mapImage.height * 0.8) / trackModelHeight );
            if (!isFinite(scaleFactorMap) || scaleFactorMap <= 0) scaleFactorMap = Math.min(mapImage.width, mapImage.height) / 0.01 ;
            initialDisplayTransform = {
                scale: scaleFactorMap, rotation: 0,
                tx: mapImage.width / 2, ty: mapImage.height / 2
            };
            controls.forEach(c => {
                const mapPixelPos = transformModelToMapPixels(c.modelX, c.modelY, initialDisplayTransform);
                c.mapX = mapPixelPos.x; c.mapY = mapPixelPos.y;
                c.isUserManuallyPositioned = false; c.isGlobalAnchor = false;
            });
            currentMode = 'idle'; activeGlobalTransform = null; globalAnchorPairs = [];
            updateGlobalAnchorListUI();
            regenerateWarpedTrack();
            updateStatus("Map and TCX loaded. Ready for alignment or fine-tuning.");
        }

        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;

            if (currentMode.startsWith('selectingControlForGlobal') || currentMode.startsWith('placingOnMapForGlobal')) {
            } else {
                activeDragControlId = null;
                if (mapImage) {
                    for (let i = controls.length - 1; i >= 0; i--) {
                        const c = controls[i];
                        const controlScreenPos = mapToScreen(c.mapX, c.mapY);
                        const distSq = (screenX - controlScreenPos.x)**2 + (screenY - controlScreenPos.y)**2;
                        if (distSq < (appearance.controlRadius + 3)**2) {
                            activeDragControlId = c.id;
                            dragOffsetX = screenX - controlScreenPos.x;
                            dragOffsetY = screenY - controlScreenPos.y;
                            canvas.style.cursor = 'grabbing';
                            if (currentMode === 'idle') currentMode = 'fineTuning';
                            c.isUserManuallyPositioned = true; 
                            c.isGlobalAnchor = false;
                            didDrag = false; // Reset drag flag
                            redrawCanvas(); return;
                        }
                    }
                }
            }
            if (!activeDragControlId && !(currentMode.startsWith('placingOnMapForGlobal'))) {
                 if (mapImage) {
                    isPanning = true; lastPanX = screenX; lastPanY = screenY;
                    canvas.style.cursor = 'grabbing';
                 }
            }
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            if (activeDragControlId) {
                didDrag = true; // It's a drag, not a click
                const control = controls.find(c => c.id === activeDragControlId);
                if (control) {
                    const targetScreenX = screenX - dragOffsetX;
                    const targetScreenY = screenY - dragOffsetY;
                    const targetMapPos = screenToMap(targetScreenX, targetScreenY);
                    control.mapX = targetMapPos.x; control.mapY = targetMapPos.y;
                    regenerateWarpedTrack(); redrawCanvas();
                }
            } else if (isPanning) {
                const dx = screenX - lastPanX; const dy = screenY - lastPanY;
                viewTransform.offsetX -= dx / viewTransform.scale;
                viewTransform.offsetY -= dy / viewTransform.scale;
                lastPanX = screenX; lastPanY = screenY;
                redrawCanvas();
            } else {
                let hoveringControl = false;
                if (mapImage && (currentMode === 'selectingControlForGlobal1' || currentMode === 'selectingControlForGlobal2' || currentMode === 'fineTuning' || currentMode === 'idle')) {
                     for (let c of controls) {
                        const controlScreenPos = mapToScreen(c.mapX, c.mapY);
                        const distSq = (screenX - controlScreenPos.x)**2 + (screenY - controlScreenPos.y)**2;
                        if (distSq < (appearance.controlRadius + 3)**2) { hoveringControl = true; break; }
                    }
                }
                if (hoveringControl) canvas.style.cursor = 'pointer';
                else if (currentMode.startsWith('placingOnMapForGlobal')) canvas.style.cursor = 'crosshair';
                else if (mapImage && !isPanning) canvas.style.cursor = 'grab';
                else canvas.style.cursor = 'default';
            }
        }

        function handleMouseUp() {
            if (activeDragControlId) { activeDragControlId = null; redrawCanvas(); }
            if (isPanning) { isPanning = false; }
            const rect = canvas.getBoundingClientRect();
            const event = new MouseEvent('mousemove', { clientX: lastPanX + rect.left, clientY: lastPanY + rect.top });
            canvas.dispatchEvent(event);
        }

        function handleMouseWheel(event) {
            if (!mapImage) return;
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseScreenX = event.clientX - rect.left;
            const mouseScreenY = event.clientY - rect.top;
            const mouseMapPosBeforeZoom = screenToMap(mouseScreenX, mouseScreenY);
            const zoomFactor = 1.1;
            const oldScale = viewTransform.scale;
            if (event.deltaY < 0) { viewTransform.scale *= zoomFactor; }
            else { viewTransform.scale /= zoomFactor; }
            viewTransform.scale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewTransform.scale));
            if (Math.abs(viewTransform.scale - oldScale) < 1e-7) return;
            viewTransform.offsetX = mouseMapPosBeforeZoom.x - (mouseScreenX / viewTransform.scale);
            viewTransform.offsetY = mouseMapPosBeforeZoom.y - (mouseScreenY / viewTransform.scale);
            redrawCanvas();
        }

        // --- HELPER: Find closest point on a polyline ---
        function getClosestPointOnPolyline(point, polyline) {
            let closest = { distance: Infinity, point: null, segmentIndex: -1, progress: 0 };
            if (polyline.length < 2) return closest;

            for (let i = 0; i < polyline.length - 1; i++) {
                const p1 = polyline[i];
                const p2 = polyline[i+1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;

                if (dx === 0 && dy === 0) continue; // Skip zero-length segments

                const t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / (dx * dx + dy * dy);
                const tClamped = Math.max(0, Math.min(1, t));

                const closestPointOnSegment = { x: p1.x + tClamped * dx, y: p1.y + tClamped * dy };
                const distSq = (point.x - closestPointOnSegment.x)**2 + (point.y - closestPointOnSegment.y)**2;

                if (distSq < closest.distance) {
                    closest = {
                        distance: distSq,
                        point: closestPointOnSegment,
                        segmentIndex: i,
                        progress: tClamped
                    };
                }
            }
            closest.distance = Math.sqrt(closest.distance);
            return closest;
        }

        // --- HELPER: Find model details for a point on the warped map track ---
        function findModelDetailsForMapPoint(mapPoint, segmentIndex, progress) {
            const trackPathAnchors = [];
            controls.forEach(c => {
                trackPathAnchors.push({ modelX: c.modelX, modelY: c.modelY, mapX: c.mapX, mapY: c.mapY,
                    originalTrackPointIndex: c.originalTrackPointIndex, id: c.id });
            });
            trackPathAnchors.sort((a, b) => a.originalTrackPointIndex - b.originalTrackPointIndex);
            const uniqueAnchors = trackPathAnchors.filter((a, i, self) => i === self.findIndex(ua => ua.originalTrackPointIndex === a.originalTrackPointIndex));

            if (segmentIndex >= displayTrackScreenPoints.length - 1 || uniqueAnchors.length < 2) return null;

            let S1_anchor = null, S2_anchor = null;
            const epsilon = 0.5; // A small tolerance for finding the anchor point

            // Search backwards from the clicked segment to find the segment's starting anchor
            for (let i = segmentIndex; i >= 0; i--) {
                const pt = displayTrackScreenPoints[i];
                const foundAnchor = uniqueAnchors.find(a => Math.abs(a.mapX - pt.x) < epsilon && Math.abs(a.mapY - pt.y) < epsilon);
                if (foundAnchor) {
                    S1_anchor = foundAnchor;
                    const s1IndexInAnchors = uniqueAnchors.findIndex(a => a.id === S1_anchor.id);
                    if (s1IndexInAnchors < uniqueAnchors.length - 1) {
                         S2_anchor = uniqueAnchors[s1IndexInAnchors + 1];
                    }
                    break;
                }
            }

            if (!S1_anchor || !S2_anchor) { 
                // Fallback for first segment if needed
                if (segmentIndex === 0) {
                    S1_anchor = uniqueAnchors[0];
                    S2_anchor = uniqueAnchors[1];
                } else {
                    console.error("Could not determine anchors for the clicked segment.");
                    return null; 
                }
            }

            // Interpolate to find the originalTrackPointIndex
            const segmentStartIndex = S1_anchor.originalTrackPointIndex;
            const segmentEndIndex = S2_anchor.originalTrackPointIndex;
            const indexSpan = segmentEndIndex - segmentStartIndex;
            
            // Find which two points in the model track the new point lies between
            const pointsInSegment = modelTrackPoints.filter(p => p.originalIndex >= segmentStartIndex && p.originalIndex <= segmentEndIndex);
            if(pointsInSegment.length < 2) return null;

            const newIndex = segmentStartIndex + (indexSpan * progress);

            // Invert the transformation for that segment to find the model point
            const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
            const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
            const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
            const den = dSmx * dSmx + dSmy * dSmy;

            let modelX, modelY;

            if (Math.abs(den) < 1e-9) {
                modelX = S1.x + progress * dSmx;
                modelY = S1.y + progress * dSmy;
            } else {
                const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);

                // Inverse transformation
                const a = sCosR_seg, b = -sSinR_seg, c = -sSinR_seg, d = -sCosR_seg;
                const det_inv = 1 / (a*d - b*c);

                const mapX_rel = mapPoint.x - Tx_seg;
                const mapY_rel = mapPoint.y - Ty_seg;

                modelX = det_inv * (d * mapX_rel - b * mapY_rel);
                modelY = det_inv * (-c * mapX_rel + a * mapY_rel);
            }

            return { modelX, modelY, originalTrackPointIndex: newIndex };
        }


        function handleCanvasClickForPlacement(event) {
            if (didDrag) {
                didDrag = false;
                return;
            }
            if (isPanning || activeDragControlId || !mapImage) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            const mapClickPos = screenToMap(screenX, screenY);

            // Check if a control was clicked
            let clickedCtrl = null;
            for (let c of controls) {
                const controlScreenPos = mapToScreen(c.mapX, c.mapY);
                const distSq = (screenX - controlScreenPos.x)**2 + (screenY - controlScreenPos.y)**2;
                if (distSq < (appearance.controlRadius + 3)**2) {
                    clickedCtrl = c;
                    break;
                }
            }

            if (clickedCtrl) {
                // A control was clicked
                if (clickedCtrl.isCustom) {
                    // Delete custom control
                    controls = controls.filter(c => c.id !== clickedCtrl.id);
                    regenerateWarpedTrack();
                    redrawCanvas();
                    updateStatus(`Custom control removed.`);
                    return;
                }

                if (currentMode === 'selectingControlForGlobal1' || currentMode === 'selectingControlForGlobal2') {
                    if (globalAnchorPairs.length === 1 && globalAnchorPairs[0].controlId === clickedCtrl.id) { 
                        updateStatus("<b>Error:</b> Cannot select the same control point twice."); 
                        return; 
                    }
                    selectedControlForPlacementId = clickedCtrl.id;
                    clickedCtrl.isGlobalAnchor = true;
                    if (currentMode === 'selectingControlForGlobal1') { 
                        currentMode = 'placingOnMapForGlobal1'; 
                        updateStatus(`<b>Step 2/4:</b> Ctrl ${clickedCtrl.id.split('-').pop()} selected. Click its location on map.`); 
                    } else { 
                        currentMode = 'placingOnMapForGlobal2'; 
                        updateStatus(`<b>Step 4/4:</b> Ctrl ${clickedCtrl.id.split('-').pop()} selected. Click its location on map.`); 
                    }
                    redrawCanvas();
                } else if (clickedCtrl.isUserManuallyPositioned && (currentMode === 'fineTuning' || currentMode === 'idle')) {
                    // Un-align the control if it was already manually positioned
                    clickedCtrl.isUserManuallyPositioned = false;
                    clickedCtrl.isGlobalAnchor = false;
                    regenerateWarpedTrack();
                    redrawCanvas();
                    updateStatus(`Control ${clickedCtrl.id.split('-').pop()} alignment reset.`);
                }
            } else {
                // The click was on the map, not a control
                if (currentMode === 'placingOnMapForGlobal1' || currentMode === 'placingOnMapForGlobal2') {
                    const controlToPlace = controls.find(c => c.id === selectedControlForPlacementId);
                    if (!controlToPlace) return;
                    controlToPlace.mapX = mapClickPos.x; controlToPlace.mapY = mapClickPos.y;
                    controlToPlace.isUserManuallyPositioned = true; controlToPlace.isGlobalAnchor = true;
                    globalAnchorPairs.push({ controlId: controlToPlace.id, mapX: mapClickPos.x, mapY: mapClickPos.y, modelX: controlToPlace.modelX, modelY: controlToPlace.modelY });
                    updateGlobalAnchorListUI();

                    if (currentMode === 'placingOnMapForGlobal1') { 
                        currentMode = 'selectingControlForGlobal2'; 
                        updateStatus(`<b>Step 3/4:</b> First pair set. Click 2nd control on track.`); 
                    } else {
                        const p1 = globalAnchorPairs[0]; const p2 = globalAnchorPairs[1];
                        const S1_model = { x: p1.modelX, y: p1.modelY }; const D1_map = { x: p1.mapX, y: p1.mapY };
                        const S2_model = { x: p2.modelX, y: p2.modelY }; const D2_map = { x: p2.mapX, y: p2.mapY };
                        const dSmx = S2_model.x - S1_model.x; const dSmy = S2_model.y - S1_model.y;
                        const dDx_map = D2_map.x - D1_map.x; const dDy_map = D2_map.y - D1_map.y;
                        const den = dSmx * dSmx + dSmy * dSmy;
                        if (Math.abs(den) < 1e-9) { updateStatus("<b>Error:</b> Model points for global alignment are identical. Reset and choose different points."); resetAlignment(); return; }
                        const sCosR = (dDx_map * dSmx - dDy_map * dSmy) / den;
                        const sSinR = (-dDx_map * dSmy - dDy_map * dSmx) / den;
                        const s_val = Math.sqrt(sCosR*sCosR + sSinR*sSinR);
                        const R_val = Math.atan2(sSinR, sCosR);
                        activeGlobalTransform = {
                            scale: s_val, rotation: R_val,
                            tx: D1_map.x - (sCosR * S1_model.x - sSinR * S1_model.y),
                            ty: D1_map.y - (-sSinR * S1_model.x - sCosR * S1_model.y)
                        };
                        controls.forEach(c => {
                            if (!c.isGlobalAnchor) {
                                const mapPixelPos = transformModelToMapPixels(c.modelX, c.modelY, activeGlobalTransform);
                                c.mapX = mapPixelPos.x; c.mapY = mapPixelPos.y;
                                c.isUserManuallyPositioned = false;
                            }
                        });
                        currentMode = 'fineTuning'; updateStatus("<b>Global Alignment Set!</b> Fine-tune by dragging controls.");
                    }
                    selectedControlForPlacementId = null;
                    regenerateWarpedTrack(); 
                    redrawCanvas();
                } else if ((currentMode === 'fineTuning' || currentMode === 'idle') && displayTrackScreenPoints.length > 1) {
                    // CREATE NEW CUSTOM CONTROL
                    const closest = getClosestPointOnPolyline(mapClickPos, displayTrackScreenPoints);
                    const clickTolerance = 10 / viewTransform.scale; // 10 screen pixels tolerance

                    if (closest.distance < clickTolerance) {
                        const modelDetails = findModelDetailsForMapPoint(closest.point, closest.segmentIndex, closest.progress);
                        if (modelDetails) {
                            const newControl = {
                                id: `control-custom-${customControlIdCounter++}`,
                                modelX: modelDetails.modelX,
                                modelY: modelDetails.modelY,
                                mapX: closest.point.x,
                                mapY: closest.point.y,
                                isUserManuallyPositioned: true, // It's manually placed by definition
                                isGlobalAnchor: false,
                                isCustom: true, // Flag for custom points
                                originalTrackPointIndex: modelDetails.originalTrackPointIndex
                            };
                            controls.push(newControl);
                            controls.sort((a,b) => a.originalTrackPointIndex - b.originalTrackPointIndex);
                            regenerateWarpedTrack();
                            redrawCanvas();
                            updateStatus(`New custom control added.`);
                        }
                    }
                }
            }
            updateButtonStates();
        }
        canvas.addEventListener('click', handleCanvasClickForPlacement);

        function regenerateWarpedTrack() {
            if (modelTrackPoints.length === 0) { displayTrackScreenPoints = []; updateButtonStates(); return; }

            const currentBaseTransform = activeGlobalTransform || initialDisplayTransform;

            // 1. Update positions of all non-manual controls based on manual anchors.
            const manualAnchors = controls.filter(c => c.isUserManuallyPositioned)
                                          .sort((a, b) => a.originalTrackPointIndex - b.originalTrackPointIndex);

            controls.forEach(c => {
                if (c.isUserManuallyPositioned) return;

                let newMapPos;
                if (manualAnchors.length === 0) {
                    newMapPos = transformModelToMapPixels(c.modelX, c.modelY, currentBaseTransform);
                } else if (manualAnchors.length === 1) {
                    const manual = manualAnchors[0];
                    const modelOffset = { x: c.modelX - manual.modelX, y: c.modelY - manual.modelY };
                    const s = currentBaseTransform.scale;
                    const R = currentBaseTransform.rotation;
                    const cosR = Math.cos(R), sinR = Math.sin(R);
                    const mapOffsetX = s * (modelOffset.x * cosR - modelOffset.y * sinR);
                    const mapOffsetY = s * (-modelOffset.x * sinR - modelOffset.y * cosR);
                    newMapPos = { x: manual.mapX + mapOffsetX, y: manual.mapY + mapOffsetY };
                } else {
                    let prevAnchor = null, nextAnchor = null;
                    for (let i = 0; i < manualAnchors.length; i++) {
                        if (manualAnchors[i].originalTrackPointIndex > c.originalTrackPointIndex) {
                            nextAnchor = manualAnchors[i];
                            break;
                        }
                        prevAnchor = manualAnchors[i];
                    }

                    let S1_anchor = prevAnchor, S2_anchor = nextAnchor;
                    if (!S1_anchor) { S1_anchor = manualAnchors[0]; S2_anchor = manualAnchors[1]; }
                    else if (!S2_anchor) { S2_anchor = manualAnchors[manualAnchors.length - 1]; S1_anchor = manualAnchors[manualAnchors.length - 2]; }

                    const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
                    const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
                    const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
                    const den = dSmx * dSmx + dSmy * dSmy;

                    if (Math.abs(den) < 1e-9) {
                        const totalIndexSpan = S2_anchor.originalTrackPointIndex - S1_anchor.originalTrackPointIndex;
                        const progress = totalIndexSpan > 0 ? (c.originalTrackPointIndex - S1_anchor.originalTrackPointIndex) / totalIndexSpan : 0;
                        newMapPos = { x: D1.x + progress * dDx, y: D1.y + progress * dDy };
                    } else {
                        const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                        const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                        const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                        const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);
                        newMapPos = {
                            x: sCosR_seg * c.modelX - sSinR_seg * c.modelY + Tx_seg,
                            y: -sSinR_seg * c.modelX - sCosR_seg * c.modelY + Ty_seg
                        };
                    }
                }
                c.mapX = newMapPos.x;
                c.mapY = newMapPos.y;
            });

            // 2. Now, build the anchor list for drawing the track line, using the updated control positions.
            const anchors = [];
            controls.forEach(c => {
                anchors.push({ modelX: c.modelX, modelY: c.modelY, mapX: c.mapX, mapY: c.mapY,
                    originalTrackPointIndex: c.originalTrackPointIndex, id: c.id });
            });

            // Add implicit start/end points if not controlled
            const trackStartIndex = modelTrackPoints[0]?.originalIndex;
            if (trackStartIndex !== undefined && !anchors.find(a => a.originalTrackPointIndex === trackStartIndex)) {
                const c = { modelX: modelTrackPoints[0].correctedX, modelY: modelTrackPoints[0].correctedY, originalTrackPointIndex: trackStartIndex };
                // Find its position just like we did for non-manual controls
                 let newMapPos;
                if (manualAnchors.length === 0) {
                    newMapPos = transformModelToMapPixels(c.modelX, c.modelY, currentBaseTransform);
                } else if (manualAnchors.length === 1) {
                    const manual = manualAnchors[0];
                    const modelOffset = { x: c.modelX - manual.modelX, y: c.modelY - manual.modelY };
                    const s = currentBaseTransform.scale;
                    const R = currentBaseTransform.rotation;
                    const cosR = Math.cos(R), sinR = Math.sin(R);
                    const mapOffsetX = s * (modelOffset.x * cosR - modelOffset.y * sinR);
                    const mapOffsetY = s * (-modelOffset.x * sinR - modelOffset.y * cosR);
                    newMapPos = { x: manual.mapX + mapOffsetX, y: manual.mapY + mapOffsetY };
                } else {
                    let prevAnchor = null, nextAnchor = null;
                    for (let i = 0; i < manualAnchors.length; i++) {
                        if (manualAnchors[i].originalTrackPointIndex > c.originalTrackPointIndex) {
                            nextAnchor = manualAnchors[i];
                            break;
                        }
                        prevAnchor = manualAnchors[i];
                    }

                    let S1_anchor = prevAnchor, S2_anchor = nextAnchor;
                    if (!S1_anchor) { S1_anchor = manualAnchors[0]; S2_anchor = manualAnchors[1]; }
                    else if (!S2_anchor) { S2_anchor = manualAnchors[manualAnchors.length - 1]; S1_anchor = manualAnchors[manualAnchors.length - 2]; }

                    const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
                    const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
                    const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
                    const den = dSmx * dSmx + dSmy * dSmy;

                    if (Math.abs(den) < 1e-9) {
                        const totalIndexSpan = S2_anchor.originalTrackPointIndex - S1_anchor.originalTrackPointIndex;
                        const progress = totalIndexSpan > 0 ? (c.originalTrackPointIndex - S1_anchor.originalTrackPointIndex) / totalIndexSpan : 0;
                        newMapPos = { x: D1.x + progress * dDx, y: D1.y + progress * dDy };
                    } else {
                        const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                        const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                        const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                        const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);
                        newMapPos = {
                            x: sCosR_seg * c.modelX - sSinR_seg * c.modelY + Tx_seg,
                            y: -sSinR_seg * c.modelX - sCosR_seg * c.modelY + Ty_seg
                        };
                    }
                }
                anchors.push({ modelX: c.modelX, modelY: c.modelY, mapX: newMapPos.x, mapY: newMapPos.y, originalTrackPointIndex: c.originalTrackPointIndex, id: 'implicit-track-start' });
            }
            // You would repeat a similar block for the track end point. For brevity, this example omits the end point logic but it would be symmetrical to the start point logic.


            anchors.sort((a, b) => a.originalTrackPointIndex - b.originalTrackPointIndex);
            const uniqueAnchors = anchors.filter((a, i, self) => i === self.findIndex(ua => ua.originalTrackPointIndex === a.originalTrackPointIndex));

            // 3. Generate the warped track line for display.
            displayTrackScreenPoints = [];
            if (uniqueAnchors.length === 0) { updateButtonStates(); return; }
            if (uniqueAnchors.length === 1) {
                modelTrackPoints.forEach(_ => displayTrackScreenPoints.push({x: uniqueAnchors[0].mapX, y: uniqueAnchors[0].mapY}));
                updateButtonStates(); return;
            }

            for (let i = 0; i < uniqueAnchors.length - 1; i++) {
                const S1_anchor = uniqueAnchors[i], S2_anchor = uniqueAnchors[i+1];
                const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
                const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
                const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
                const den = dSmx * dSmx + dSmy * dSmy;

                const segmentModelPoints = modelTrackPoints.filter(p => p.originalIndex >= S1_anchor.originalTrackPointIndex && p.originalIndex <= S2_anchor.originalTrackPointIndex).sort((p1,p2)=>p1.originalIndex-p2.originalIndex);

                if (Math.abs(den) < 1e-9) {
                    segmentModelPoints.forEach(modelPt => {
                        const totalIndexSpan = S2_anchor.originalTrackPointIndex - S1_anchor.originalTrackPointIndex;
                        const progress = totalIndexSpan > 0 ? (modelPt.originalIndex - S1_anchor.originalTrackPointIndex) / totalIndexSpan : 0;
                        displayTrackScreenPoints.push({ x: D1.x + progress * dDx, y: D1.y + progress * dDy });
                    });
                } else {
                    const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                    const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                    const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                    const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);
                    segmentModelPoints.forEach(modelPt => {
                        displayTrackScreenPoints.push({
                            x: sCosR_seg * modelPt.correctedX - sSinR_seg * modelPt.correctedY + Tx_seg,
                            y: -sSinR_seg * modelPt.correctedX - sCosR_seg * modelPt.correctedY + Ty_seg
                        });
                    });
                }
            }
            if (displayTrackScreenPoints.length > 1) {
                displayTrackScreenPoints = displayTrackScreenPoints.filter((point, index, self) =>
                    index === 0 || !self[index-1] || Math.abs(point.x - self[index-1].x) > 0.1 || Math.abs(point.y - self[index-1].y) > 0.1
                );
            }
            updateButtonStates();
        }

        function redrawCanvas() {
            if (!canvas.width || !canvas.height) { console.warn("Canvas not sized for redraw"); return; }
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!mapImage && originalTrackPoints.length === 0) {
                ctx.fillStyle = '#eee'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#777'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = `16px sans-serif`;
                ctx.fillText('Load map and TCX file', canvas.width / 2, canvas.height / 2);
                return;
            }
            ctx.save();
            ctx.scale(viewTransform.scale, viewTransform.scale);
            ctx.translate(-viewTransform.offsetX, -viewTransform.offsetY);

            if (mapImage) {
                const viewXInMapCoords = viewTransform.offsetX;
                const viewYInMapCoords = viewTransform.offsetY;
                const viewWidthInMapCoords = canvas.width / viewTransform.scale;
                const viewHeightInMapCoords = canvas.height / viewTransform.scale;
                const sx = Math.max(0, viewXInMapCoords);
                const sy = Math.max(0, viewYInMapCoords);
                const sEndX = Math.min(mapImage.width, viewXInMapCoords + viewWidthInMapCoords);
                const sEndY = Math.min(mapImage.height, viewYInMapCoords + viewHeightInMapCoords);
                const sWidth = sEndX - sx;
                const sHeight = sEndY - sy;
                if (sWidth > 0 && sHeight > 0) {
                    const dx = sx; const dy = sy; const dWidth = sWidth; const dHeight = sHeight;
                    ctx.drawImage(mapImage, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight );
                }
            } else {
                ctx.fillStyle = '#ddd';
                ctx.fillRect(viewTransform.offsetX, viewTransform.offsetY, canvas.width / viewTransform.scale, canvas.height / viewTransform.scale);
                const fontSize = 20 / viewTransform.scale; ctx.font = `${fontSize}px sans-serif`;
                ctx.fillStyle = '#777'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('Load map', viewTransform.offsetX + (canvas.width / viewTransform.scale) / 2, viewTransform.offsetY + (canvas.height / viewTransform.scale) / 2);
            }

            if (displayTrackScreenPoints.length > 1) {
                ctx.beginPath(); ctx.strokeStyle = appearance.trackColor;
                ctx.lineWidth = appearance.trackWidth / viewTransform.scale;
                ctx.moveTo(displayTrackScreenPoints[0].x, displayTrackScreenPoints[0].y);
                for (let i = 1; i < displayTrackScreenPoints.length; i++) {
                    ctx.lineTo(displayTrackScreenPoints[i].x, displayTrackScreenPoints[i].y);
                }
                ctx.stroke();
            }
            controls.forEach(c => {
                ctx.beginPath();
                let fillColor = appearance.controlColorInitial;
                if (c.isCustom) {
                    fillColor = appearance.controlColorCustom;
                } else if (c.isUserManuallyPositioned) {
                    fillColor = appearance.controlColor;
                } else if (activeGlobalTransform) {
                    fillColor = appearance.controlColorGlobal;
                }

                if (selectedControlForPlacementId === c.id && (currentMode.startsWith('placingOnMap') || currentMode.startsWith('selectingControl'))) fillColor = 'orange';
                else if (activeDragControlId === c.id) fillColor = 'rgba(255,165,0,0.8)';
                ctx.arc(c.mapX, c.mapY, appearance.controlRadius / viewTransform.scale, 0, 2 * Math.PI);
                ctx.strokeStyle = fillColor;
                ctx.lineWidth = (appearance.trackWidth / viewTransform.scale) / 2;
                ctx.stroke();

                if (c.isGlobalAnchor && globalAnchorPairs.find(p=>p.controlId === c.id)) {
                    ctx.strokeStyle = 'lime';
                    ctx.lineWidth = (appearance.trackWidth / viewTransform.scale) / 2;
                    ctx.stroke();
                }
            });
            ctx.restore();
        }

        function startGlobalAlignment() {
            if (!mapImage || originalTrackPoints.length === 0) return;
            globalAnchorPairs = [];
            controls.forEach(c => { c.isGlobalAnchor = false; });
            currentMode = 'selectingControlForGlobal1';
            updateStatus("<b>Step 1/4:</b> Click 1st control on track.");
            updateButtonStates(); updateGlobalAnchorListUI(); redrawCanvas();
        }
        function resetAlignment() {
            if (!mapImage || originalTrackPoints.length === 0) { updateStatus("Load files first."); return; }
            processLoadedDataAndSetInitialDisplay();
            activeGlobalTransform = null;
            globalAnchorPairs = [];
            updateGlobalAnchorListUI();
            currentMode = 'idle';
            updateStatus("Alignment reset to initial state.");
            updateButtonStates();
            if (mapImage) zoomToFitMap(); else redrawCanvas();
        }
        function updateGlobalAnchorListUI() {
            globalAnchorListEl.innerHTML = '';
            globalAnchorPairs.forEach((pair, index) => {
                const control = controls.find(c => c.id === pair.controlId);
                const li = document.createElement('li');
                let displayName = control ? control.id : '??';
                if (control && control.id.includes('-')) {
                    displayName = control.id.substring(control.id.lastIndexOf('-') + 1);
                }
                li.textContent = `Pair ${index+1}: Ctrl ${displayName} at Map (${pair.mapX.toFixed(0)}, ${pair.mapY.toFixed(0)})`;
                globalAnchorListEl.appendChild(li);
            });
        }

        // --- NEW FUNCTION TO SAVE IMAGE ---
        function saveImage() {
            if (!mapImage || displayTrackScreenPoints.length === 0) {
                updateStatus("Cannot save. Load map and ensure track is processed.");
                return;
            }

            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = mapImage.width;
            offscreenCanvas.height = mapImage.height;
            const offCtx = offscreenCanvas.getContext('2d');

            // 1. Draw the map image
            offCtx.drawImage(mapImage, 0, 0, mapImage.width, mapImage.height);

            // 2. Draw the track
            if (displayTrackScreenPoints.length > 1) {
                offCtx.beginPath();
                offCtx.strokeStyle = appearance.trackColor;
                // Use the absolute trackWidth for export, not scaled by viewTransform
                offCtx.lineWidth = appearance.trackWidth;
                offCtx.moveTo(displayTrackScreenPoints[0].x, displayTrackScreenPoints[0].y);
                for (let i = 1; i < displayTrackScreenPoints.length; i++) {
                    offCtx.lineTo(displayTrackScreenPoints[i].x, displayTrackScreenPoints[i].y);
                }
                offCtx.stroke();
            }

            // 3. Draw the controls
            controls.forEach(c => {
                offCtx.beginPath();
                let fillColor = appearance.controlColorInitial;
                // Simplified color logic for export:
                if (c.isUserManuallyPositioned) {
                    fillColor = appearance.controlColor;
                } else if (activeGlobalTransform && !c.isUserManuallyPositioned) { // Check if part of a global transform solution
                    // A simple check could be if its mapX, mapY were derived from activeGlobalTransform
                    // For now, let's assume if activeGlobalTransform exists and control wasn't manually moved, it's 'global'
                     const posFromGlobal = transformModelToMapPixels(c.modelX, c.modelY, activeGlobalTransform);
                     //This check is a bit redundant if logic in regenerateWarpedTrack is right
                     //but safe for coloring.
                     if(Math.abs(c.mapX - posFromGlobal.x) < 1 && Math.abs(c.mapY - posFromGlobal.y) < 1){
                         fillColor = appearance.controlColorGlobal;
                     } else if (c.isUserManuallyPositioned) { // Re-check, as it might have been set by global then moved
                        fillColor = appearance.controlColor;
                     }
                }


                // Use the absolute controlRadius for export
                offCtx.arc(c.mapX, c.mapY, appearance.controlRadius, 0, 2 * Math.PI);
                offCtx.strokeStyle = fillColor;
                offCtx.lineWidth = appearance.trackWidth / 2;
                offCtx.stroke();

                if (c.isGlobalAnchor && globalAnchorPairs.find(p=>p.controlId === c.id)) {
                    offCtx.strokeStyle = 'lime';
                    offCtx.lineWidth = appearance.trackWidth / 2;
                    offCtx.stroke();
                }
            });

            // 4. Generate filename and trigger download
            let filename = "map_with_track_gemini.png"; // Default
            if (originalMapFileName) {
                const dotIndex = originalMapFileName.lastIndexOf('.');
                if (dotIndex > 0) {
                    const basename = originalMapFileName.substring(0, dotIndex);
                    const extension = originalMapFileName.substring(dotIndex); // e.g. ".jpg"
                    filename = `${basename}_gemini${extension}`;
                } else if (dotIndex === 0) { // Starts with a dot e.g. ".hiddenfile"
                     filename = `${originalMapFileName}_gemini`; // Or handle differently
                } else { // No extension
                    filename = `${originalMapFileName}_gemini.png`; // Add .png if no original ext
                }
            }
             // Force PNG for output consistency for now, easier than handling mapImage.type
            if (!filename.toLowerCase().endsWith('.png')) {
                const dotIndex = filename.lastIndexOf('.');
                if (dotIndex > 0) filename = filename.substring(0, dotIndex) + ".png";
                else filename = filename + ".png";
            }


            const dataURL = offscreenCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            updateStatus(`Image saved as ${filename}`);
        }


        window.addEventListener('resize', () => {
            if (mapImage) {
                const canvasContainer = document.querySelector('.canvas-container');
                canvas.width = canvasContainer.clientWidth;
                canvas.height = canvasContainer.clientHeight;
                zoomToFitMap();
            } else if (canvas.width > 0 && canvas.height > 0) {
                 const canvasContainer = document.querySelector('.canvas-container');
                 canvas.width = canvasContainer.clientWidth;
                 canvas.height = canvasContainer.clientHeight;
                 redrawCanvas();
            }
        });

        init();
    </script>
</body>
</html>
</body>
</html>